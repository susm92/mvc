{% extends "base.html.twig" %}

{% block title %}Report{% endblock %}

{% block body %}
    <h1>Report</h1>
    <h2 id="kmom01">Kmom01</h2>
        <p>
            En liten del av det stötte vi på i kursen Javascript, utöver det stötte jag även på det när vi jobbade med kursen OOPython, då vi "enbart" jobbade objektorienterat.
            <br>
            Tycker dock att det än idag är lite svårt att greppa och tänka kring de objektorienterade termerna, men i och med att vi över på det mer och mer bör det bli "lättare" när vi går framåt.
            <br><br>
            Generellt vill jag säga att för att börja skapa egna objekt och klasser i PHP eller något annat programmeringsspråk så måste vi titta till hur klassen är uppbyggd, om där skall finnas privata medlemsvariablar som då kallas properties samt om dessa skall sättas som publika, privata eller skyddade (enbart med arv att göra).
            <br>
            Funktionerna i en klass kallas för metoder, klasser kan då ses som mallar för vad som skall finnas för våra framtida objekt som då skapas från en klass. Simpla klasser tilldelas en variabel med = 'new klassnamn()', vad vi gjort då är instansierat ett objekt av en klass. Vi kan nu (om de är publika) ändra i medlemsvariablar för just detta objekt med -> (this), för att sätta specifika properties för just detta objektet.
            <br><br>
            Mycket av uppgiften ges i övningen, jag tycker om hur vi delar upp allting i mindre delar och på så sätt försöker hålla koll på dem individuellt istället för att klumpa ihop allting.
            <br>
            Svårast just nu är väl att ta till sig ett nytt ramverk, sedan tillkommer där även en hel del nya begrepp och kod som kan vara svårt att ta till sig nu i början.
            <br><br>
            Olika programmerings paradigmer, databasinteraktion, server and deployment.
            <br>
            Är några av de olika områdena som verkar främst intressanta för min del och något som jag hade velat fördjupa mig mer i från artikeln.
            <br><br>
            Symfoni, TWIG, objektorienterad PHP, autoloader
        </p>
    <h2 id="kmom02">Kmom02</h2>
        <p>
            I följande moment har vi fått använda oss av konstruktioner så som arv, komposition, interface och trait för att lösa veckans uppgift. Denna veckan har vi fått ägna oss åt att försöka föreställa en kortlek, där vi skapat sidor för att då försöka plocka nya kort, bland hela kortleken och även då visa ett antal kort.
            <br><br>
            Om vi börjar med komposition, så finns där två typer av kompositioner, stakt kopplade som då kallas för aggregat, eller svagt kopplade. Ett exempel på detta är en lägenhet, i lägenheten finns där ett antal rum, vi kan inte ta rummen från lägenheten och så fort lägenheten försvinner (rivs) så försvinner även rummen, detta är då starkt kopplade objekt. Talar vi istället om personerna som bor i en lägenhet så är de inte i lika starkt beroende då de exempelvis kan flytta till en annan lägenhet, detta är då en svag koppling. I php kan detta som som metoder som då instansierar objekt för en annan klass. Brukar vanligtvis kunna hittas med "has a" benämningen.
            Arv till skillnad från ovan brukar vanligtvis användas för att utöka en basklass med extra funktionalitet eller metoder, benämningen här brukar gå under 'is a'. När det kommer sig till arv så är det så att den ärvda klassen (subklassen) vanligtvis har tillgång till alla medlemsvariabler och metoder (så länge de inte är privata i basklassen) från basklassen. I php används detta med benämningen 'extends'. När det sen kommer sig till Traits och Interface, så är det så att ett trait är väldigt likt arv men är då enbart fyllt med metoder och medlemsvariabler som i sig kan nyttjas av en annan klass för att utöka dess funktionalitet. Vi kommer åt funktionalitet av ett trait från en klass med use 'trait-namnet'. Medan ett interface mer är tänkt som ett kontrakt där en klass lovar att erbjuda en viss uppsättning metoder, istället för class 'namn', benämns dessa för interface 'namn'.
            <br><br>
            Jag använde mig exempelvis av komposition och arv för att lösa denna veckans uppgift, min huvudklass är i mina ögon Card klassen, denna ärver i sin tur ner till DeckOfCards, som då är en samling av kort. CardHand har i sin tur en aggregation mot klassen Card, där CardHand använder sig av ett Card-objekt för att kunna fungera som tänkt.
            <br><br>
            Överlag vill jag påstå att jag är nöjd med min applikation även om den kändes väldigt stor och hade en hel del motgångar, nu i efterhand kan jag se att där återanvänds kod lite här och där i vissa routes.. det är nog en idé att till nästa kmom när mer tid finnes få iordning på detta så att jag kan få det att se snyggare ut. Veckans uppgift har lyckats ta upp hur sessioner används i PHP/ TWIG, Routes med Request/ Session, arv i PHP.
        </p>
    <h2 id="kmom03">Kmom03</h2>
        <p>
            I kmom03 har vi fått arbeta med flödesdiagram, skriva pseudokod med fokus på problemlösning. Följande moment såg väldigt utmanande ut i början men så fort man fått stolpa upp kraven och vad som förväntas från våran del, blev det lättare att visualisera hur denna uppgiften skulle klaras av.
            <br><br>
            För min del var upplevelsen att det jobbigaste med detta kmom var just hur vi skulle tackla uppgiften, då den med största sannolikhet går att lösa på många sätt är frågan just hur går jag från A->B så smidigt som möjligt. Här tyckte jag att Polyas fyra faser kom till bra användning då jag via papper och penna först började med att visualisera hur jag skulle göra och ta mig an innan jag började koda. Det slutade dock med att jag hade ett skrivbord fullt med kladdpapper överallt men så for jag kommit fram till något som såg någorlunda konkret ut började jag koda efter den lösningen. Jag tycker även generellt att det hjälpte att tänka igenom hur man vill göra innan man sätter igång, men ibland kan det vara en fördel med att bara börja med projektet och ta det som det kommer, lite så blev det när jag skulle få ihop mitt flödesdiagram och min pseudokod.. Flödesdiagrammet skapades utan större bekymmer men pseudokoden var svår att förhålla sig till då jag inte kommit till den biten än, det blev att jag började med poängsättningen och när jag väl började närma mig bankens funktioner så gick jag tillbaka till hur pseudokoden för banken kan se ut.
            <br><br>
            Slutligen fick jag ihop ett mindre program där användaren kan spela mot datorn, datorn i detta fallet är tyvärr väldigt dum idag men jag ser potentialen till att i framtiden återkomma till detta moment och se ifall man kan göra datorn smartare, eller mer tävlingsinriktad. Överlag är jag ganska nöjd med min uppsättning, från tidigare moment gick jag även vidare med att slopa strängarna och tillämpa ordentliga kort så att det blir mer intuitivt och roligare att faktiskt spela spelet. Jag försökte även förhålla mig till S och D i SOLID men kan tycka att det var lättare sagt än gjort, tittar vi på .D i denna förteckning så vill jag föreställa mig att det gick någorlunda bra, medan .S delen var svårare då även om jag ville hålla nere funktioner/ routes så blev det att man var tvungen att lägga till mer och mer funktioner för att få det att faktiskt spela. Här känner jag att jag har mer att lära..
            <br><br>
            När det sedan kommer sig till ramverket vi jobbar i är jag lite kluven, speciellt då jag i kmom01 och kmom02 verkligen kämpade med att få i ordning på routes, includes och ibland enbart för att kunna ladda sidor, detta har överlag blivit mycket smidigare, men med det sagt känns det ändå som om lärningskurvan för detta ramverk är ganska högt då man ibland får fel som gör så man får klia sig på huvudet en extra gång innan man kommer i mål.
            <br><br>
            Vill bara nämna att jag med lintern för detta moment valt att låta vissa fel stå kvar, speciellt då jag inte hittat 'vettiga' förklaringar online eller då jag inte ser hur jag på annat sätt skall skriva om koden så att den uppfyller samma funktionalitet. Detta gäller specifikt för PHPSTAN som då klagar på att jag inte har några typer när jag injicerar objekt i metoder, någon av mina if/ else statement i mina routes.. 
            <br>
            Jag tänker mig dock att jag i kmom06->kmom01, får bli bättre på detta och då skuva upp error level till 9 igen.
            <br><br>
            Min TIL för denna gång är mer twig, problemlösning generellt.
        </p>
    <h2 id="kmom04">Kmom04</h2>
        <p>
            Kmom04 avslutades med att vi fick använda oss av phpunit för att testa våran kod, så att den lever upp till de förväntningar som förväntas, vi fick även använda oss av phpDoc för att dokumentera våran kod.
            <br><br>
            Vad jag uppskattade med verktygen i detta kmom var att det gick så smidigt att sätta upp och installera, och sedan var det bara att börja använda sig av dem. Jag uppskattade även att bägge verktygen skapade en index hemsida som man lätt kunde använda sig av för att följa sina framsteg efter varje test eller dokumentation som lades till.
            <br><br>
            Tittar vi till kodtäckningen av min kod lyckades jag få ihop 100% kodtäckning, men för att få till detta fick jag lägga till extra metoder för att hämta och sätta variabler i min Card class och även i min GraphicDeckOfCards. Tittar man till Card klassen lades en getter metod till för att hämta nyvarande värde på den skyddade variablen i klassen, jag lade även till en metod för att visa hela klassen som håller korten. I den senare klassen lade jag till en metod för att testa så att poängsättningen faktiskt fungerar som tänkt.
            <br><br>
            Överlag är jag nöjd med min kod och mina tester, jag kan dock tycka att det var lite klurigt att komma på olika testfall då man inte vill utföra "onödiga" tester på koden och då min kod var relativt simpel, beslutade jag mig för att hålla mig till tester som faktiskt testar så att metoderna gör det de säger sig skall göra.
            <br><br>
            Jag kan absolut se fördelarna med att testa sin kod och med tester då verifiera så att koden faktiskt gör det den förväntas göra. Men om vi tittar på ämnet 'snygg och ren kod' är min mening att det lättast görs genom att hålla metoder och funktioner simpla och specifika till det de just skall göra, det skall vara lätt att se vad koden faktiskt gör, detta kan vara lättare att uppnå om man använder sig av tester men detta blir oftast beroende på hur testerna är utfärdade och vem som skriver koden. Överlag är min mening att testbar kod är "snyggare och renare".
            <br><br>
            Min TL för detta kmom är phpunit i Symfoni och även phpDoc, skriva testbar kod.  
            
        </p>
    <h2 id="kmom05">Kmom05</h2>
        <p>
            Härmed avslutas även kmom05, i följande moment fick vi använda oss av Doctrine via Symfony för att skapa en lokal databas som vi jobbade mot, i uppgiften skapade vi ett bibliotek för just detta ändamål.
            <br><br>
            Övningen vi utgick ifrån var enligt mig väldigt enkel att följa och gav oss en bra grund att stå på inför uppgiften. Tog dock ett tag för mig att inse att metoderna för repositoryt står utkommenterat i php filen i respektive repository.. Men ju mer man satt med det flöt det på bättre och bättre.
            <br><br>
            Överlag vill jag påstå att det gick relativt smärtfritt att jobba med ORM i CRUD, när man väl satt upp Read/ Create så flöt det mesta på av sig självt, det var lite segt i början gällande hur man skall ta sig an uppgiften men allt eftersom blev det lättare och lättare. Tyckte även att det var oerhört smidigt att installera Doctrine och skapa databasen för att sedan lätt via terminalen lägga till Entity, som då skapar controller med fullstängiga metoder för de tabeller man använder sig av.
            <br><br>
            När det kommer sig till mitt projekt i detta kmom valde jag att använda mig av liknande layout som tidigare men att jag då ser till att där finns knappar för att skapa, ändra, ta bort och så vidare, samt för att avbryta och gå tillbaka till första sidan. Detta blev enligt mig väldigt lyckat och jag vill påstå att mitt bibliotek känns som om det hänger ihop på ett bra sätt. I tabellerna visar jag upp titel, isbn, författaren och även en liten bild i form av en länk till vart bilden är hämtad från.
            <br><br>
            ORM i Symfony var smidigt och lätt att sätta upp och börja jobba med, jag kan tänka mig att det är smidigt att använda sig av speciellt om man då behöver en liten databas för att spara ett litet antal information eller autentiseringsuppgifter, men så fort mer data behöver tillämpas ser jag ett bekymmer med prestandan (beroende på vart den körs), och då kanske en dedikerad SQL server eller liknande hade varit bättre att arbeta mot..
            <br><br>
            Min TIL för detta kmom är: ORM i Symfony, CRUD med ORD
        </p>
    <h2 id="kmom06">Kmom06</h2>
    <p>
        Vi avslutar nu kmom06 som då handlade om hur vi använder verktyg som Scrutinizer och PhpMetrics för att få fram rapporter kring våran kod samt projekt gällande kodtäckning, kodkvalité och diverse mätvärden.
        <br><br>
        Överlag kändes PhpMetrics smidigt att använda sig av samt att det gav ett visuellt intryck på hur koden är skriven och metoderna är upplagda. Första sidan av rapporten ger ett samlat värde på hur stort projekter är, antalet klasser, tester och komplexitet samt ifall där finns några potentiella buggar man bör ha i åtanke.
        <br><br>
        Jag kan uppskatta att rapporten är lätt att läsa och följa, men något jag är lite sådär med är att man inte kan läsa lika långt ner i trädstrukturen på klasserna som listas under exempelvis complexity, man ser ett samlat värde för hur klass komplexiteten ser ut men det går inte att klicka på klassen som i Scrutinizer för att få fram metoderna.. Detta gör det väl lämpat till att använda programmet till att få en översiktlig bild över sin kod men om man behöver gå in på djupet så uppskattar jag Scrutinizer mer.
        <br><br>
        Vad jag tyckte om med Scrutinizer var att man verkligen kunde gå ner på djupet gällande kod komplexitet per metoder i en klass, kodtäckningen för klasser och metoder samt som jag tog upp tidigare, medan i PhpMetrics var det mer översiktligt på klasserna. Gällande badges som finns i Scrutinizer så är det nice att man får det så pass översiktligt så att man kan kopiera ut dem till sina projekt och sedan hänvisa till dem så att andra kan se att man faktiskt jobbar med kodkvalité på sin kod. Jag hade väl lite tur här då jag fick 10.0 i kodkvalité redan från start, inte så mycket jobb krävdes från min sida där, dock var kodtäckningen relativt låg i början på blyga 12.5%.
        <br><br>
        Ovan verktyg tror jag är ett bra val för att börja jobba mot begreppet 'clean code', i min mening är det väl även en uppmaning till att använda sig av badges för framtida projekt så att andra kan se att man faktiskt har detta med snygg kod och kodkvalitet i bakgrunden och aktivit jobbar med det. Till viss mån påvisar badges att man aktivt jobbar med sin kod och kodkvaliteten överlag, något det dock inte kan påvisa är hur pass 'seriöst' man tittar över det, för även om man får höga scoren, är väl att beroende på hur pass komplicerat projektet är.. Ett lättare projekt har lättare för att faktiskt ge högre siffror än ett 'svårare'..
        <br><br>
        Min til till denna gången är 'clean code', PhpMetrics, Scrutinizer, re-Factoring av kod.
    </p>
{% endblock %}