{% extends "base.html.twig" %}

{% block title %}Report{% endblock %}

{% block body %}
    <h1>Report</h1>
    <h2 id="kmom01">Kmom01</h2>
        <p>
            En liten del av det stötte vi på i kursen Javascript, utöver det stötte jag även på det när vi jobbade med kursen OOPython, då vi "enbart" jobbade objektorienterat.
            <br>
            Tycker dock att det än idag är lite svårt att greppa och tänka kring de objektorienterade termerna, men i och med att vi över på det mer och mer bör det bli "lättare" när vi går framåt.
            <br><br>
            Generellt vill jag säga att för att börja skapa egna objekt och klasser i PHP eller något annat programmeringsspråk så måste vi titta till hur klassen är uppbyggd, om där skall finnas privata medlemsvariablar som då kallas properties samt om dessa skall sättas som publika, privata eller skyddade (enbart med arv att göra).
            <br>
            Funktionerna i en klass kallas för metoder, klasser kan då ses som mallar för vad som skall finnas för våra framtida objekt som då skapas från en klass. Simpla klasser tilldelas en variabel med = 'new klassnamn()', vad vi gjort då är instansierat ett objekt av en klass. Vi kan nu (om de är publika) ändra i medlemsvariablar för just detta objekt med -> (this), för att sätta specifika properties för just detta objektet.
            <br><br>
            Mycket av uppgiften ges i övningen, jag tycker om hur vi delar upp allting i mindre delar och på så sätt försöker hålla koll på dem individuellt istället för att klumpa ihop allting.
            <br>
            Svårast just nu är väl att ta till sig ett nytt ramverk, sedan tillkommer där även en hel del nya begrepp och kod som kan vara svårt att ta till sig nu i början.
            <br><br>
            Olika programmerings paradigmer, databasinteraktion, server and deployment.
            <br>
            Är några av de olika områdena som verkar främst intressanta för min del och något som jag hade velat fördjupa mig mer i från artikeln.
            <br><br>
            Symfoni, TWIG, objektorienterad PHP, autoloader
        </p>
    <h2 id="kmom02">Kmom02</h2>
        <p>
            I följande moment har vi fått använda oss av konstruktioner så som arv, komposition, interface och trait för att lösa veckans uppgift. Denna veckan har vi fått ägna oss åt att försöka föreställa en kortlek, där vi skapat sidor för att då försöka plocka nya kort, bland hela kortleken och även då visa ett antal kort.
            <br><br>
            Om vi börjar med komposition, så finns där två typer av kompositioner, stakt kopplade som då kallas för aggregat, eller svagt kopplade. Ett exempel på detta är en lägenhet, i lägenheten finns där ett antal rum, vi kan inte ta rummen från lägenheten och så fort lägenheten försvinner (rivs) så försvinner även rummen, detta är då starkt kopplade objekt. Talar vi istället om personerna som bor i en lägenhet så är de inte i lika starkt beroende då de exempelvis kan flytta till en annan lägenhet, detta är då en svag koppling. I php kan detta som som metoder som då instansierar objekt för en annan klass. Brukar vanligtvis kunna hittas med "has a" benämningen.
            Arv till skillnad från ovan brukar vanligtvis användas för att utöka en basklass med extra funktionalitet eller metoder, benämningen här brukar gå under 'is a'. När det kommer sig till arv så är det så att den ärvda klassen (subklassen) vanligtvis har tillgång till alla medlemsvariabler och metoder (så länge de inte är privata i basklassen) från basklassen. I php används detta med benämningen 'extends'. När det sen kommer sig till Traits och Interface, så är det så att ett trait är väldigt likt arv men är då enbart fyllt med metoder och medlemsvariabler som i sig kan nyttjas av en annan klass för att utöka dess funktionalitet. Vi kommer åt funktionalitet av ett trait från en klass med use 'trait-namnet'. Medan ett interface mer är tänkt som ett kontrakt där en klass lovar att erbjuda en viss uppsättning metoder, istället för class 'namn', benämns dessa för interface 'namn'.
            <br><br>
            Jag använde mig exempelvis av komposition och arv för att lösa denna veckans uppgift, min huvudklass är i mina ögon Card klassen, denna ärver i sin tur ner till DeckOfCards, som då är en samling av kort. CardHand har i sin tur en aggregation mot klassen Card, där CardHand använder sig av ett Card-objekt för att kunna fungera som tänkt.
            <br><br>
            Överlag vill jag påstå att jag är nöjd med min applikation även om den kändes väldigt stor och hade en hel del motgångar, nu i efterhand kan jag se att där återanvänds kod lite här och där i vissa routes.. det är nog en idé att till nästa kmom när mer tid finnes få iordning på detta så att jag kan få det att se snyggare ut. Veckans uppgift har lyckats ta upp hur sessioner används i PHP/ TWIG, Routes med Request/ Session, arv i PHP.
        </p>
    <h2 id="kmom03">Kmom03</h2>
        <p>
            I kmom03 har vi fått arbeta med flödesdiagram, skriva pseudokod med fokus på problemlösning. Följande moment såg väldigt utmanande ut i början men så fort man fått stolpa upp kraven och vad som förväntas från våran del, blev det lättare att visualisera hur denna uppgiften skulle klaras av.
            <br><br>
            För min del var upplevelsen att det jobbigaste med detta kmom var just hur vi skulle tackla uppgiften, då den med största sannolikhet går att lösa på många sätt är frågan just hur går jag från A->B så smidigt som möjligt. Här tyckte jag att Polyas fyra faser kom till bra användning då jag via papper och penna först började med att visualisera hur jag skulle göra och ta mig an innan jag började koda. Det slutade dock med att jag hade ett skrivbord fullt med kladdpapper överallt men så for jag kommit fram till något som såg någorlunda konkret ut började jag koda efter den lösningen. Jag tycker även generellt att det hjälpte att tänka igenom hur man vill göra innan man sätter igång, men ibland kan det vara en fördel med att bara börja med projektet och ta det som det kommer, lite så blev det när jag skulle få ihop mitt flödesdiagram och min pseudokod.. Flödesdiagrammet skapades utan större bekymmer men pseudokoden var svår att förhålla sig till då jag inte kommit till den biten än, det blev att jag började med poängsättningen och när jag väl började närma mig bankens funktioner så gick jag tillbaka till hur pseudokoden för banken kan se ut.
            <br><br>
            Slutligen fick jag ihop ett mindre program där användaren kan spela mot datorn, datorn i detta fallet är tyvärr väldigt dum idag men jag ser potentialen till att i framtiden återkomma till detta moment och se ifall man kan göra datorn smartare, eller mer tävlingsinriktad. Överlag är jag ganska nöjd med min uppsättning, från tidigare moment gick jag även vidare med att slopa strängarna och tillämpa ordentliga kort så att det blir mer intuitivt och roligare att faktiskt spela spelet. Jag försökte även förhålla mig till S och D i SOLID men kan tycka att det var lättare sagt än gjort, tittar vi på .D i denna förteckning så vill jag föreställa mig att det gick någorlunda bra, medan .S delen var svårare då även om jag ville hålla nere funktioner/ routes så blev det att man var tvungen att lägga till mer och mer funktioner för att få det att faktiskt spela. Här känner jag att jag har mer att lära..
            <br><br>
            När det sedan kommer sig till ramverket vi jobbar i är jag lite kluven, speciellt då jag i kmom01 och kmom02 verkligen kämpade med att få i ordning på routes, includes och ibland enbart för att kunna ladda sidor, detta har överlag blivit mycket smidigare, men med det sagt känns det ändå som om lärningskurvan för detta ramverk är ganska högt då man ibland får fel som gör så man får klia sig på huvudet en extra gång innan man kommer i mål.
            <br><br>
            Vill bara nämna att jag med lintern för detta moment valt att låta vissa fel stå kvar, speciellt då jag inte hittat 'vettiga' förklaringar online eller då jag inte ser hur jag på annat sätt skall skriva om koden så att den uppfyller samma funktionalitet. Detta gäller specifikt för PHPSTAN som då klagar på att jag inte har några typer när jag injicerar objekt i metoder, någon av mina if/ else statement i mina routes.. 
            <br>
            Jag tänker mig dock att jag i kmom06->kmom01, får bli bättre på detta och då skuva upp error level till 9 igen.
            <br><br>
            Min TIL för denna gång är mer twig, problemlösning generellt.
        </p>
    <h2 id="kmom04">Kmom04</h2>
        <p>
            Kmom04 avslutades med att vi fick använda oss av phpunit för att testa våran kod, så att den lever upp till de förväntningar som förväntas, vi fick även använda oss av phpDoc för att dokumentera våran kod.
            <br><br>
            Vad jag uppskattade med verktygen i detta kmom var att det gick så smidigt att sätta upp och installera, och sedan var det bara att börja använda sig av dem. Jag uppskattade även att bägge verktygen skapade en index hemsida som man lätt kunde använda sig av för att följa sina framsteg efter varje test eller dokumentation som lades till.
            <br><br>
            Tittar vi till kodtäckningen av min kod lyckades jag få ihop 100% kodtäckning, men för att få till detta fick jag lägga till extra metoder för att hämta och sätta variabler i min Card class och även i min GraphicDeckOfCards. Tittar man till Card klassen lades en getter metod till för att hämta nyvarande värde på den skyddade variablen i klassen, jag lade även till en metod för att visa hela klassen som håller korten. I den senare klassen lade jag till en metod för att testa så att poängsättningen faktiskt fungerar som tänkt.
            <br><br>
            Överlag är jag nöjd med min kod och mina tester, jag kan dock tycka att det var lite klurigt att komma på olika testfall då man inte vill utföra "onödiga" tester på koden och då min kod var relativt simpel, beslutade jag mig för att hålla mig till tester som faktiskt testar så att metoderna gör det de säger sig skall göra.
            <br><br>
            Jag kan absolut se fördelarna med att testa sin kod och med tester då verifiera så att koden faktiskt gör det den förväntas göra. Men om vi tittar på ämnet 'snygg och ren kod' är min mening att det lättast görs genom att hålla metoder och funktioner simpla och specifika till det de just skall göra, det skall vara lätt att se vad koden faktiskt gör, detta kan vara lättare att uppnå om man använder sig av tester men detta blir oftast beroende på hur testerna är utfärdade och vem som skriver koden. Överlag är min mening att testbar kod är "snyggare och renare".
            <br><br>
            Min TL för detta kmom är phpunit i Symfoni och även phpDoc, skriva testbar kod.  
            
        </p>
    <h2 id="kmom05">Kmom05</h2>
    <h2 id="kmom06">Kmom06</h2>
{% endblock %}